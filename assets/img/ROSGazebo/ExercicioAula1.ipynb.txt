{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "unlikely-summer",
   "metadata": {},
   "source": [
    "# Exercício Aula 1\n",
    "# Nome:\n",
    "# NUSP:"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "moved-exemption",
   "metadata": {},
   "source": [
    "- Construir um código para o Jogo da Vida denominado High Life\n",
    "- A regra desse jogo é dada por B36/S23, ou seja, uma célula nasce (Born) se houverem 3 or 6 vizinhos, sobrevive (Survive) se houverem 2 ou 3 vizinhos, e morre caso contrário.\n",
    "- Modificar o código abaixo.\n",
    "- **O teste do programa deve ser feito com o padrão replicator (Veja abaixo).**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "hearing-robertson",
   "metadata": {},
   "outputs": [],
   "source": [
    "def CriaGameOfLife(Dimensao,NumGeracoes,Padrao,linp,colp):\n",
    "    flag=False\n",
    "    Matrix=[[False for y in range(Dimensao)] for x in range(Dimensao)]\n",
    "    if Inicializa(Matrix,Padrao,linp,colp):\n",
    "       PrintDisplay(Matrix)                        # estado inicial\n",
    "       for k in range(1,NumGeracoes+1):\n",
    "           input('Press enter to continue: ')\n",
    "           Matrix = UpdateMatrix(Matrix)\n",
    "           PrintDisplay(Matrix)\n",
    "           # print  Matrix\n",
    "       flag=True\n",
    "    return(flag)\n",
    "    # (linp,colp) coordenadas na Matriz A\n",
    "    # onde o canto superior esquerdo do padrao deve coincidir\n",
    "    #\n",
    "def Inicializa(A,Padrao,linp,colp):\n",
    "    # dimensoes da matriz A\n",
    "    nlinesA = len(A)\n",
    "    ncolsA  = len(A[0])\n",
    "    # dimesoes do padrao\n",
    "    nlinesPadrao=len(Padrao)\n",
    "    ncolsPadrao =len(Padrao[0])\n",
    "    \n",
    "    flag=False\n",
    "    # Testa se (linp,colp) e'uma coordenada valida na matriz\n",
    "    if (linp in range(nlinesA)) and (colp in range(ncolsA)):\n",
    "       if (linp+nlinesPadrao-1 in range(nlinesA)) and (colp+ncolsPadrao-1 in range(ncolsA)):\n",
    "           flag=True\n",
    "           for i in range(nlinesPadrao):\n",
    "               for j in range(ncolsPadrao):\n",
    "                   if Padrao[i][j]==1:\n",
    "                      A[linp+i][colp+j]=True\n",
    "                   else:\n",
    "                      A[linp+i][colp+j]=False\n",
    "    return(flag) # True se foi possivel inserir o padrao False caso contrario\n",
    "    \n",
    "\n",
    "def ContaVizinhos(Matrix, lin, col): # Conta o numero de celulas vizinhas que estao vivas\n",
    "                                     # (lin,col) posicao da celula\n",
    "    contador = 0\n",
    "        # (lin,col) posicao da celula\n",
    "        # Dimensoes do array Matrix nao sao conhecidos\n",
    "        # Pressuposto que indices (lin,col) nao se referem a uma celula\n",
    "        # na borda do array\n",
    "\n",
    "    # coloque o seu codigo aqui\n",
    "\n",
    "\n",
    "    return contador\n",
    "        \n",
    "def UpdateMatrix(MatrixVelha): # Calcula a nova geracao de celulas\n",
    "    # recupero as dimensoes da matriz\n",
    "    numlines = len(MatrixVelha)\n",
    "    numcols  = len(MatrixVelha[0])\n",
    "    # defino uma nova matrix de celulas com as mesmas dimensoes\n",
    "    MatrixNova=[[False for y in range(numcols)] for x in range(numlines)]\n",
    "                                          # a borda da matriz e' sempre False (celulas mortas)\n",
    "    for i in range(1,numlines-1):         # comeca da segunda linha e termina na penultima linha\n",
    "        for j in range(1,numcols-1):      # idem para colunas\n",
    "          # Coloque aqui o seu código\n",
    "          # contendo as regras de vida e morte\n",
    "          # Utilize a funcao ContaVizinhos()\n",
    "          MatrixNova[i][j]=MatrixVelha[i][j]          \n",
    "    return MatrixNova\n",
    "                    \n",
    "def PrintDisplay(a):\n",
    "    # recupera dimensoes do objeto a\n",
    "    numlines = len(a)\n",
    "    numcols  = len(a[0])\n",
    "    print('Geracao')\n",
    "    for i in range(numlines):\n",
    "        for j in range(numcols):\n",
    "            if a[i][j] == True:\n",
    "                print('o ',end=\"\")\n",
    "            else:     #   it must be False of course !\n",
    "                print('. ',end=\"\")\n",
    "        print(end=\"\\n\")\n",
    "        \n",
    "def Conversao(A):\n",
    "    nlinesA = len(A)\n",
    "    ncolsA  = len(A[0])    \n",
    "    B=[['. ' for y in range(ncolsA)] for x in range(nlinesA)]\n",
    "    for i in range(nlinesA):\n",
    "        for j in range(ncolsA):\n",
    "            if A[i][j] == True:\n",
    "               B[i][j] = 'o '\n",
    "    return(B)\n",
    "    \n",
    "# Devido a limitacoes da implementacao       \n",
    "# Padrao nao pode ser uma unica linha\n",
    "#       \n",
    "blinker = [[0,0,0],[1,1,1],[0,0,0]]\n",
    "# fonte http://www.math.cornell.edu/~lipa/mec/lesson6.html\n",
    "toad = [[0,1,1,1],[1,1,1,0]]\n",
    "#https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n",
    "tetrominoe = [[0,1,0],[1,1,1]] # Padrao vai aumentando de area\n",
    "# fonte http://www.math.cornell.edu/~lipa/mec/lesson6.html\n",
    "behived = [[1,0,0],[1,1,1]] # estabiliza em 3 geracoes\n",
    "# fonte http://www.ibiblio.org/lifepatterns/october1970.html\n",
    "smallexploder=[[0,1,0],[1,1,1],[1,0,1],[0,1,0]]\n",
    "glider=[[0,1,0],[0,0,1],[1,1,1]] # desloca no sentido diagonal\n",
    "cellrow=[[0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,0]]\n",
    "lightweightspaceship=[[0,1,1,1,1],[1,0,0,0,1],[0,0,0,0,1],[1,0,0,1,0]]\n",
    "gosperglidergun=[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0],\n",
    "[0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],\n",
    "[0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "external-yugoslavia",
   "metadata": {},
   "source": [
    "- O programa pode ser testado fazendo uma chamada à função CriaGameOfLife(Dimensao,NumGeracoes,Padrao,linp,colp):\n",
    "- Dimensao = dimensão do array\n",
    "- NumGeracoes = número de gerações que serão simuladas\n",
    "- Padrao = array contendo um padrão de inicialização pré-definido, como blinker, toad, tetrominoe, etc. (verificar acima)\n",
    "- (linp, colp) = índices do array que coincide com o canto superior esquerdo do padrão\n",
    "\n",
    "- **O teste deve ser feito com o padrão denominado replicator como ilustrado na célula abaixo**"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "limited-principal",
   "metadata": {},
   "outputs": [],
   "source": [
    "replicator=[[0,0,1,1,1],[0,1,0,0,1],[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0]]\n",
    "CriaGameOfLife(40,20,replicator,20,20)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "included-burlington",
   "metadata": {},
   "source": [
    "## Jogo da vida com interface gráfica\n",
    "\n",
    "- O código apresentado a seguir é a versão notebook do arquivo gui.py que gera uma interface gráfica para o Jogo da Vida.\n",
    "\n",
    "- O código tem comandos em python, javascript e qml.\n",
    "\n",
    "- A interface é criada através da biblioteca Qt.\n",
    "\n",
    "- O código utiliza a função UpdateMatrix desenvolvida na célula acima.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "grave-functionality",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "Created on Mon Mar 27 15:26:30 2017\n",
    "\n",
    "    Uma implementação de front-end gráfico em QML e pyqt5 para o Game Of Life\n",
    "    do prof. Newton Maruyama.\n",
    "    Esta implementação busca deliberadamente minimizar a quantidade de código\n",
    "    em JavaScript (para evitar confundir os alunos com duas linguagens).\n",
    "    Provavelmente seria mais eficiente fazer o engine qml processar o conteúdo\n",
    "    da matriz do jogo em javascript diretamente.\n",
    "\n",
    "@author: thiago\n",
    "\"\"\"\n",
    "import sys\n",
    "from PyQt5.QtWidgets import QApplication\n",
    "from PyQt5.QtQml import QQmlApplicationEngine, qmlRegisterType\n",
    "from PyQt5.QtCore import QObject, Qt, QVariant, QAbstractListModel, QModelIndex, pyqtProperty, pyqtSignal, pyqtSlot, QTimer\n",
    "\n",
    "# As linhas a seguir não são utilizadas na versão jupyter notebook\n",
    "#import JogoDaVidaAluno\n",
    "#import JogoDaVida\n",
    "\n",
    "class Cell(QObject):\n",
    "    \n",
    "    def __init__(self,  i, j, matrix, parent=None):\n",
    "        super().__init__(parent)\n",
    "        self._i = i\n",
    "        self._j = j\n",
    "        self._matrix = matrix\n",
    "    \n",
    "    aliveChanged = pyqtSignal()\n",
    "    @pyqtProperty(bool,notify=aliveChanged)\n",
    "    def alive(self):\n",
    "        return self._matrix[self._j][self._i]\n",
    "\n",
    "  \n",
    "class GameModel(QAbstractListModel):\n",
    "    aliveRole = Qt.UserRole + 1\n",
    "    def __init__(self, parent=None, *args): \n",
    "        super(GameModel, self).__init__(parent)\n",
    "        self._rows = 50\n",
    "        self._cols = 50\n",
    "        self._matrix =[[False for i in range(self._cols)] for j in range(self._rows)]\n",
    "        self._Cells = [[Cell(i, j, self._matrix) for i in range(self._cols)] for j in range(self._rows)]\n",
    "        self._timer = QTimer()\n",
    "        self._timer.timeout.connect(self.gameStep)\n",
    "        self._speed = 120\n",
    "        self._timer.setInterval(60000//self._speed)\n",
    "        self._playing = False\n",
    "    \n",
    "    @pyqtSlot(int)\n",
    "    def toogleCell(self, index):\n",
    "        i = index %  self._cols\n",
    "        j = index // self._rows\n",
    "        self._matrix[j][i] ^= True\n",
    "        self._Cells[j][i].aliveChanged.emit()\n",
    "    \n",
    "    @pyqtSlot()\n",
    "    def gameStep(self):\n",
    "        # Na versao notebook nao existe o import do arquivo JogoDaVida\n",
    "        # mas sim uma chamada de UpdateMatrix da celula acima\n",
    "        newMatrix = UpdateMatrix(self._matrix)\n",
    "        # newMatrix = JogoDaVida.UpdateMatrix(self._matrix)\n",
    "        # newMatrix = JogoDaVidaAluno.UpdateMatrix(self._matrix)\n",
    "        for j in range(len(self._matrix)):\n",
    "            for i in range(len(self._matrix[j])):\n",
    "                self._matrix[j][i] = newMatrix[j][i]\n",
    "        self.dataChanged.emit(self.createIndex(0,0),self.createIndex(self._rows*self._cols,0))\n",
    "                \n",
    "    @pyqtSlot()\n",
    "    def gameGo(self):\n",
    "        self._playing = True\n",
    "        self._timer.start()\n",
    "        self.playingChanged.emit()\n",
    "        \n",
    "    @pyqtSlot()\n",
    "    def gameStop(self):\n",
    "        self._playing = False\n",
    "        self._timer.stop()\n",
    "        self.playingChanged.emit()\n",
    "        \n",
    "    playingChanged = pyqtSignal()\n",
    "    @pyqtProperty(bool,notify=playingChanged)\n",
    "    def playing(self):\n",
    "        return self._playing  \n",
    "    \n",
    "    speedChanged = pyqtSignal()\n",
    "    @pyqtProperty(int,notify=speedChanged)\n",
    "    def speed(self):\n",
    "        return self._speed\n",
    "    @speed.setter\n",
    "    def setSpeed(self,value):\n",
    "        self._speed = value\n",
    "        self._timer.setInterval(60000//self._speed) \n",
    "        \n",
    "    rowsChanged = pyqtSignal()\n",
    "    @pyqtProperty(int,notify=rowsChanged)\n",
    "    def rows(self):\n",
    "        return self._rows\n",
    "    \n",
    "    colsChanged = pyqtSignal()    \n",
    "    @pyqtProperty(int, notify=colsChanged)\n",
    "    def cols(self):\n",
    "        return self._cols\n",
    "    \n",
    "    def rowCount(self, parent=QModelIndex()):\n",
    "        return self._rows*self._cols\n",
    "        \n",
    "    def data(self, index, role=Qt.DisplayRole):\n",
    "        if role == self.aliveRole:\n",
    "            i = index.row() %  self._cols\n",
    "            j = index.row() // self._rows\n",
    "            return self._Cells[j][i]\n",
    "        else:\n",
    "            return QVariant()\n",
    "        \n",
    "    def roleNames(self):\n",
    "        names = {}\n",
    "        names[self.aliveRole] = b\"alive\"\n",
    "        return names\n",
    "    \n",
    "        \n",
    "# Main Function\n",
    "if __name__ == '__main__':\n",
    "    # Create main app\n",
    "    myApp = QApplication(sys.argv)\n",
    "    \n",
    "    qmlRegisterType(Cell, 'Cell', 1, 0, 'Cell')\n",
    "    \n",
    "    # Load QML\n",
    "    engine = QQmlApplicationEngine()\n",
    "    game = GameModel()\n",
    "    engine.rootContext().setContextProperty(\"game\", game)\n",
    "    \n",
    "    engine.load('qml/GoLGrid.qml')\n",
    "    # Create Window\n",
    "    window = engine.rootObjects()[0]    \n",
    "    #print(QMetaObject.invokeMethod(array,'itemAt(int)', Qt.BlockingQueuedConnection, Q_RETURN_ARG(int), Q_ARG(int, 0)))\n",
    "    # Execute the Application and Exit\n",
    "    sys.exit(myApp.exec_())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "rotary-royal",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
